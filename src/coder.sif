
_coder_base64_padding: u8 = '=';
_coder_base64_alphabet: [64]u8;
_coder_base64_indices: [256]i16;

// josh  hasn't yet fixed the 'bug' with 
//   array/struct literals in the global 
//   field  this  code  is temporary and 
//   will  be  fixed,  when josh updates
//   his language.
proc coder_init_globals() {
  _coder_base64_alphabet = .{
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
    'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 
    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 
    'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 
    'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 
    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 
    'w', 'x', 'y', 'z', '0', '1', '2', '3', 
    '4', '5', '6', '7', '8', '9', '+', '/', 
  };
  _coder_base64_indices = .{
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,62,  -1, -1, -1, 63,
    52, 53, 54, 55, 56, 57, 58, 59, 60,61,  -1, -1, -1, -1, -1, -1,
    -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
    -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  };
}

struct coder {
  
  proc to_base64(allocator: Allocator, bytes: []u8): []u8 {
    input_size: int = bytes.count;
    output_size: int;
    
    round_up_size: int = input_size;
    mod: int = round_up_size % 3;
    if(mod != 0) {
      round_up_size += 3 - mod;
    }
    assert(round_up_size % 3 == 0);
    output_size = round_up_size * 4 / 3;
    output : []u8 = new_slice(u8, output_size, allocator);
    
    source_index: = 0;
    target_index: = 0;
    remainder: = 0;
    
    for(;source_index+3 <= input_size; source_index += 3) {
      x: = cast(int, bytes[source_index+0]);
      y: = cast(int, bytes[source_index+1]);
      z: = cast(int, bytes[source_index+2]);
      output[target_index+0] = _coder_base64_alphabet[x >> 2];
      output[target_index+1] = _coder_base64_alphabet[(0x30 & (x << 4)) | (y >> 4)];
      output[target_index+2] = _coder_base64_alphabet[(0x3C & (y << 2)) | (z >> 6)];
      output[target_index+3] = _coder_base64_alphabet[0x3F & z];
      target_index += 4;
    }
    
    padding: int = 3 - (input_size - source_index);
    if(padding == 2) {
      x: = cast(int, bytes[source_index+0]);
      output[target_index+0] = _coder_base64_alphabet[x >> 2];
      output[target_index+1] = _coder_base64_alphabet[(0x30 & (x << 4))];
      output[target_index+2] = _coder_base64_padding;
      output[target_index+3] = _coder_base64_padding;
    }
    else if(padding == 1) {
      x: = cast(int, bytes[source_index+0]);
      y: = cast(int, bytes[source_index+1]);
      output[target_index+0] = _coder_base64_alphabet[x >> 2];
      output[target_index+1] = _coder_base64_alphabet[(0x30 & (x << 4)) | (y >> 4)];
      output[target_index+2] = _coder_base64_alphabet[(0x3C & (y << 2))];
      output[target_index+3] = _coder_base64_padding;
    }
    
    return output;
  }
  
  proc is_base64(byte_string: []u8): bool {
    if(byte_string.count == 0) return true;
    if(byte_string.count % 4 != 0) return false;
    equal_count: int = 0;
    for(i: = 0; i < byte_string.count; i += 1) {
      c: = byte_string[i];
      valid: = false;
      if(_coder_base64_indices[cast(int,c)] == -1) {
        if(c == '=') {
          equal_count += 1;
          if(equal_count >= 3) return false;
          if(i < byte_string.count - 2) return false;
        }
        else return false;
      }
    }
    for(i: = byte_string.count - 1; i >= byte_string.count - equal_count; i -= 1) {
      if(byte_string[i] != '=') {
        return false;
      }
    }
    return true;
  }
  
  proc from_base64(allocator: Allocator, base_64: []u8): []u8 {
    output_size: int = base_64.count / 4 * 3;
    if(base_64[base_64.count - 1] == _coder_base64_padding) output_size -= 1;
    if(base_64[base_64.count - 2] == _coder_base64_padding) output_size -= 1;
    
    output: []u8 = new_slice(u8, output_size, allocator);
    
    source_index: = 0;
    output_index: = 0;
    for(; source_index+4 < base_64.count; source_index += 4) {
      a: u8 = cast(u8, _coder_base64_indices[cast(int, base_64[source_index+0])]);
      b: u8 = cast(u8, _coder_base64_indices[cast(int, base_64[source_index+1])]);
      c: u8 = cast(u8, _coder_base64_indices[cast(int, base_64[source_index+2])]);
      d: u8 = cast(u8, _coder_base64_indices[cast(int, base_64[source_index+3])]);
      output[output_index+0] = (a << 2) | (b >> 4);
      output[output_index+1] = (0xF0 & (b << 4)) | (c >> 2);
      output[output_index+2] = (0xC0 & (c << 6)) | d;
      output_index += 3;
    }
    
    a: = _coder_base64_indices[cast(int, base_64[source_index+0])];
    b: = _coder_base64_indices[cast(int, base_64[source_index+1])];
    c: = _coder_base64_indices[cast(int, base_64[source_index+2])];
    d: = _coder_base64_indices[cast(int, base_64[source_index+3])];
    output[output_index+0] = cast(u8, (a << 2) | (b >> 4));
    if(c != -1) output[output_index+1] = cast(u8, (0xF0 & (b << 4)) | (c >> 2));
    if(d != -1) output[output_index+2] = cast(u8, (0xC0 & (c << 6)) | d);
    
    return output;
  }
  
  
  
};
